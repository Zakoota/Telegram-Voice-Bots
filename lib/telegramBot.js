"use strict";
const request = require('./request'),
    config = require('./config'),
    fs = require('fs');

class TelegramBot {
    constructor(name) {
        this.groups = [];
        this.groupsWarned = [];
        this.lastSentIndex = 0;
        this.audioFiles = ['empty'];
        this.bot_configs = {};

        this.bot_configs = config.bots[name];

        this.audioFiles = ['empty'].concat(fs.readdirSync(__dirname + '/..' + config.publicDir + '/' + name).map(file => {
            file = file.split('.');
            return '/' + file[0];
        }));

        setInterval((_this) => {
            _this.groups = [];
            _this.groupsWarned = [];
        }, 12e4, this);
    }
    get config() {
        return this.bot_configs;
    }
    _send(a, callback) {
        request(
            config.telegram_api + "/bot" + this.bot_configs.token + "/" + a.endpoint, {
                json: a.data
            },
            callback);
    }
    setWebhook() {
        this._send({
            endpoint: 'setWebhook',
            data: {
                url: config.domain + '/' + this.bot_configs.path
            }
        }, (res, err, body) => {
            console.log(`SetWebhook Bot`, body);
        });
    }
    delWebhook(callback) {
        this._send({
            endpoint: 'deleteWebhook',
        }, (res, err, body) => {
            callback(body);
        });
    }
    getWebhook(callback) {
        this._send({
            endpoint: 'getWebhookInfo',
        }, (res, err, body) => {
            callback(body);
        });
    }
    setCommands(callback) {
        let _this = this;
        this._send({
            endpoint: 'setMyCommands',
            data: {
                commands: this.audioFiles.map((file, index) => {
                    if (index == 0) {
                        return {
                            command: _this.bot_configs.name,
                            description: "Send random audio from collection"
                        }
                    } else {
                        return {
                            command: file,
                            description: '[AUTOGENERATED]'
                        }
                    }
                })
            }
        }, (res, err, body) => {
            callback(body)
        });
    }
    processCommand(message) { 
        if (message && message.text && message.text.charAt(0) == '/') {
            let msgText = message.text.split('@');
            message.text = msgText[0];
            if (msgText.length <= 1 || msgText[1] == this.bot_configs.username) {
                let replyMessageId = null;
                let capt = null;
                if (message &&
                    message.message_id &&
                    message.from &&
                    !message.from.is_bot &&
                    message.from.id
                ) {
                    if (message.from.id == message.chat.id) {
                        replyMessageId = message.message_id;
                    } else {
                        if (!this.groups[message.from.id + '' + message.chat.id]) {
                            this.groups[message.from.id + '' + message.chat.id] = 0
                        }
                        if (this.groups[message.from.id + '' + message.chat.id] < 2) {
                            if (message.reply_to_message &&
                                message.reply_to_message.from.id != message.from.id &&
                                message.chat.id == message.reply_to_message.chat.id) {
                                if (message.reply_to_message.from.username) {
                                    capt = '@' + message.reply_to_message.from.username;
                                } else {
                                    capt = `[${message.reply_to_message.from.first_name || message.reply_to_message.from.last_name}](tg://user?id=${message.reply_to_message.from.id})`;
                                }
                            }
                            replyMessageId = message.message_id;
                            this.groups[message.from.id + '' + message.chat.id]++;
                        } else {
                            if (!this.groupsWarned[message.from.id + '' + message.chat.id]) {
                                this._send({
                                    endpoint: 'sendMessage',
                                    data: {
                                        chat_id: message.chat.id,
                                        reply_to_message_id: message.message_id,
                                        text: 'Please refrain from spamming. I am in 2 minutes cooldown now. Try again later!'
                                    }
                                }, (res, err, body) => {
                                    if (res.statusCode != 200) {
                                        console.log(JSON.stringify(body));
                                    }
                                });
                                this.groupsWarned[message.from.id + '' + message.chat.id] = 1;
                            }
                            return;
                        }

                    }
                }
                if (replyMessageId) {
                    let randNum = Math.floor(Math.random() * (this.audioFiles.length - 1)) + 1;
                    let audioPath = config.domain;
                    while (randNum == this.lastSentIndex) {
                        randNum = Math.floor(Math.random() * (this.audioFiles.length - 1)) + 1;
                    }
                    message.text = message.text.trim();

                    if (message.text == ('/' + this.bot_configs.name)) {
                        audioPath += config.publicDir + '/' + this.bot_configs.name + this.audioFiles[randNum];
                    } else if (this.audioFiles.includes(message.text)) {
                        audioPath += config.publicDir + '/' + this.bot_configs.name + message.text;
                    }
                    if (audioPath != config.domain) {
                        setTimeout((_this) => {
                            _this._send({
                                endpoint: 'sendVoice',
                                data: {
                                    chat_id: message.chat.id,
                                    reply_to_message_id: replyMessageId,
                                    voice: audioPath,
                                    caption: capt || '',
                                    parse_mode: 'Markdown'
                                }
                            }, (res, err, body) => {
                                if (res.statusCode != 200) {
                                    console.log('#' + randNum, audioPath, ':', JSON.stringify(body));
                                }
                                if (body && !body.ok) {
                                    switch (body.error_code) {
                                        case 400: {
                                            _this._send({
                                                endpoint: 'sendDocument',
                                                data: {
                                                    chat_id: message.chat.id,
                                                    reply_to_message_id: replyMessageId,
                                                    document: audioPath,
                                                    caption: capt || '',
                                                    parse_mode: 'Markdown'
                                                }
                                            }, (res, err, body) => {
                                                if (res.statusCode != 200) {
                                                    console.log('sent as DOC: #' + randNum, audioPath, ':', JSON.stringify(body));
                                                }
                                            });
                                            break;
                                        }
                                    }
                                }
                            });
                        }, 200, this);
                    }
                }
            }
        }
    }
}
module.exports = TelegramBot;